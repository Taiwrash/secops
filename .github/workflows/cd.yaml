name: CD with Script using AWSCLI

on:
  workflow_dispatch:
    inputs:
      action:
        description: "AWSCLI Creation Actions"
        required: true
        default: "create"
        type: choice
        options:
          - create
          - destroy
      environment:
        description: "Deployment environment"
        required: true
        default: "dev"

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      
      - name: Execute commands via SSM
        if: github.event.inputs.action == 'create'
        id : execute_command
        run: |
          aws ssm send-command \
            --instance-ids ${{ secrets.AWS_INSTANCE_ID }} \
            --document-name "AWS-RunShellScript" \
            --comment "Install Docker if missing and deploy app container" \
            --parameters commands="[
              \"set -e\",
              \"if ! command -v docker >/dev/null 2>&1; then\",
              \"  echo 'Docker not found. Installing Docker...'\",
              \"  apt-get update -y\",
              \"  apt-get install -y ca-certificates curl gnupg lsb-release'\",
              \"  curl -fsSL https://get.docker.com | sh'\",
              \"  systemctl enable docker'\",
              \"  systemctl start docker'\",
              \"  usermod -aG docker ubuntu || true'\",
              \"else\",
              \"  echo 'Docker already installed'\",
              \"fi\",
              \"docker pull taiwrash/secops:latest'\",
              \"docker stop secops || true'\",
              \"docker rm secops || true'\",
              \"docker run -d --restart unless-stopped --name secops -p 5000:5000 taiwrash/secops:latest'\"
            ]"
       
      - name: ALB
        if: github.event.inputs.action == 'create'
        run: |
          set -e

          # =========================
          # CONFIGURATION
          # =========================
          REGION="us-east-1"
          VPC_ID=${{secrets.VPC_ID}}
          INSTANCE_ID=${{ secrets.AWS_INSTANCE_ID }}
          INSTANCE_SG_ID=${{secrets.EC2_SG_ID}}
          SUBNET_1=${{secrets.SUBNET_ID_1}}
          SUBNET_2=${{secrets.SUBNET_ID_2}}

          ALB_NAME="secops-alb"
          TG_NAME="secops-tg"
          ALB_SG_NAME="secops-for-alb-sg"

          APP_PORT=5000
          ALB_PORT=80

          export AWS_DEFAULT_REGION=$REGION
          # =========================
          # SECURITY GROUP (ALB)
          # =========================
          echo "Resolving ALB Security Group..."

          ALB_SG_ID=$(aws ec2 describe-security-groups \
            --filters Name=group-name,Values=$ALB_SG_NAME Name=vpc-id,Values=$VPC_ID \
            --query "SecurityGroups[0].GroupId" \
            --output text)

          if [[ "$ALB_SG_ID" == "None" || -z "$ALB_SG_ID" ]]; then
            echo "Creating ALB security group..."
            ALB_SG_ID=$(aws ec2 create-security-group \
              --group-name $ALB_SG_NAME \
              --description "ALB SG for secops app" \
              --vpc-id $VPC_ID \
              --query GroupId \
              --output text)

            aws ec2 authorize-security-group-ingress \
              --group-id $ALB_SG_ID \
              --protocol tcp \
              --port $ALB_PORT \
              --cidr 0.0.0.0/0
          else
            echo "Reusing ALB security group: $ALB_SG_ID"
          fi

          # Allow ALB â†’ EC2
          aws ec2 authorize-security-group-ingress \
            --group-id $INSTANCE_SG_ID \
            --protocol tcp \
            --port $APP_PORT \
            --source-group $ALB_SG_ID || true

          # =========================
          # TARGET GROUP
          # =========================
          echo "Resolving Target Group..."

          TG_ARN=$(aws elbv2 describe-target-groups \
            --names $TG_NAME \
            --query "TargetGroups[0].TargetGroupArn" \
            --output text 2>/dev/null || true)

          if [[ "$TG_ARN" == "None" || -z "$TG_ARN" ]]; then
            echo "Creating Target Group..."
            TG_ARN=$(aws elbv2 create-target-group \
              --name $TG_NAME \
              --protocol HTTP \
              --port $APP_PORT \
              --vpc-id $VPC_ID \
              --target-type instance \
              --health-check-path "/" \
              --query "TargetGroups[0].TargetGroupArn" \
              --output text)
          else
            echo "Reusing Target Group: $TG_ARN"
          fi

          aws elbv2 register-targets \
            --target-group-arn $TG_ARN \
            --targets Id=$INSTANCE_ID,Port=$APP_PORT

          # =========================
          # APPLICATION LOAD BALANCER
          # =========================
          echo "Resolving ALB..."

          ALB_ARN=$(aws elbv2 describe-load-balancers \
            --names $ALB_NAME \
            --query "LoadBalancers[0].LoadBalancerArn" \
            --output text 2>/dev/null || true)

          if [[ "$ALB_ARN" == "None" || -z "$ALB_ARN" ]]; then
            echo "Creating ALB..."
            ALB_ARN=$(aws elbv2 create-load-balancer \
              --name $ALB_NAME \
              --subnets $SUBNET_1 $SUBNET_2 \
              --security-groups $ALB_SG_ID \
              --scheme internet-facing \
              --type application \
              --ip-address-type ipv4 \
              --query "LoadBalancers[0].LoadBalancerArn" \
              --output text)
          else
            echo "Reusing ALB: $ALB_ARN"
          fi

          # =========================
          # LISTENER
          # =========================
          echo "Ensuring Listener exists..."

          LISTENER_ARN=$(aws elbv2 describe-listeners \
            --load-balancer-arn $ALB_ARN \
            --query "Listeners[?Port==\`$ALB_PORT\`].ListenerArn" \
            --output text)

          if [[ -z "$LISTENER_ARN" ]]; then
            aws elbv2 create-listener \
              --load-balancer-arn $ALB_ARN \
              --protocol HTTP \
              --port $ALB_PORT \
              --default-actions Type=forward,TargetGroupArn=$TG_ARN
          fi

          # =========================
          # OUTPUT
          # =========================
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --load-balancer-arns $ALB_ARN \
            --query "LoadBalancers[0].DNSName" \
            --output text)

          echo "======================================="
          echo "ALB DNS: http://$ALB_DNS"
          echo "======================================="

          # =========================
          # EXPORT FOR CLEANUP STEP
          # =========================
          echo "ALB_ARN=$ALB_ARN" >> $GITHUB_ENV
          echo "TG_ARN=$TG_ARN" >> $GITHUB_ENV
          echo "ALB_SG_ID=$ALB_SG_ID" >> $GITHUB_ENV

      - name: Cleanup AWS resources on failure
        if: github.event.inputs.action == 'destroy'
        run: |
          set +e

          if [ -n "$ALB_ARN" ]; then
            aws elbv2 delete-load-balancer --load-balancer-arn "$ALB_ARN"
            aws elbv2 wait load-balancers-deleted --load-balancer-arns "$ALB_ARN"
          else
            echo "ALB_ARN not set, skipping ALB deletion"
          fi

          if [ -n "$TG_ARN" ]; then
            aws elbv2 delete-target-group --target-group-arn "$TG_ARN"
          else
            echo "TG_ARN not set, skipping target group deletion"
          fi

          if [ -n "$ALB_SG_ID" ]; then
            aws ec2 delete-security-group --group-id "$ALB_SG_ID"
          else
            echo "ALB_SG_ID not set, skipping security group deletion"
          fi





